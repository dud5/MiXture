\documentclass[12pt,a4paper, twoside]{article}
\usepackage{a4wide}
\usepackage{needspace}
\usepackage{titlesec}

\bibliographystyle{IEEEtran}
\newcommand{\fs}{F\nolinebreak\hspace{-.05em}\raisebox{.6ex}{\tiny\bf
    \#}}

\parindent 0pt
\parskip 6pt

\begin{document}
\titleformat{\section}
{\needspace{2in}\Large\bfseries}{\thesection}{1em}{}
\begin{titlepage}
\thispagestyle{empty}

\rightline{\large Eduardo Munoz} \medskip \rightline{\large Magdalene
  College} \medskip \rightline{\large em487}

\vfil

\centerline{\large Computer Science Tripos Part II Project Proposal}
\vspace{0.4in} \centerline{\Large \textbf{Multilanguage programming in
  \fs\ and JavaScript}} \vspace{0.3in} \centerline{\large \emph{\today}}

\vfil

\textbf{Project Originator:} \emph{Eduardo Munoz}

\vspace{0.5in}

\textbf{Project Supervisor:} \emph{Tomas Petricek}

\vspace{0.2in}

\textbf{Signature:}

\vspace{0.5in}

\textbf{Director of Studies:} \emph{Dr John Fawcett}

\vspace{0.2in}

{\bf Signature:}

\vspace{0.5in}

\textbf{Overseers:} \emph{Dr S. Teufel} and \emph{Dr J. Crowcroft}

\vspace{0.2in}

\textbf{Signatures:}

\vfil \eject
\end{titlepage}

\section{Introduction and description of the work}

Selecting the programming language to use when implementing a certain
algorithm is crucial to the success of the project. For this reason,
large scale software systems tend to be written in several
languages. However, the interactions between these components may be
an issue.  There are several approaches to tackle this:

\begin{enumerate}

\item \textbf{Foreign function interfaces (FFI).} Mechanism by which a
program written in one language may call procedures from a program in
a different language. The Java Native Interface is an example of a FFI.

\item \textbf{Multilanguage runtimes.} Several programming languages
target the same architecture, allowing a richer interaction between
the languages: e.g., inherit classes in one language defined in another,
call higher-order functions, etc. Examples of multilanguage runtimes
targeting the Java Virtual Machine are Java, Scala, Jython and JRuby; all
programs written for the .NET framework target the Common Language Runtime.

\item \textbf{Embedded interpreters.} Implement an interpreter of the
target language in the host language and use type-indexed embedding
and projection algorithms \cite{journals/jfp/Benton05}. Lua-ML is an
example of this technique, where a Lua interpreter is implemented in
OCaml \cite{journals/entcs/Ramsey06}.

\end{enumerate}

In this project, we intend to explore the ideas described by Matthews and Findler
\cite{journals/toplas/MatthewsF09}, for an ML-like language and
JavaScript\footnote{In this project, JavaScript is not utilized as
client-side language in the browser, but as a general purpose
language.}. This includes producing an implementation of the
\emph{lump embedding} and the \emph{natural embedding}. The former
concept is related to FFI frameworks, where each environment sees
foreign values across the boundary as ``lumps'' (values with an opaque
type). The natural embedding provides a richer interoperability
between the two languages, allowing values to be converted across the
boundary from one language to the other. The implementation for the
natural embedding can be seen as FFI with some properties of
multilanguage runtimes.

An example of using the lump embedding (note that the syntax and types
haven't been decided yet, this is for illustrative purposes):

\begin{verbatim}
    (* eval_js x : Lump list -> Lump is provided by the framework *)
    let apply_lump f x = eval_js([f,x]);
    let succ:Lump = JS("function(a) {return a+1;}")
    in apply_lump(succ, JS(“3”));

    > val it: JS(“4”) : Lump
\end{verbatim}

In this case, the ML-like language interacts JavaScript values (of
type \texttt{Lump}), by applying the value \texttt{3$_{JS}$} to the
JavaScript function \texttt{succ}.

An example of using the natural embedding (note that the syntax and
types haven't been decided yet, this is for illustrative purposes):

\begin{verbatim}
    let test (f:string->unit) :unit = f("testing")
    in test(JS(string, unit, "function(s) {print(s)}"));
    > val it: () : unit
\end{verbatim}

We can see the natural embedding allows a richer interaction between
the two languages. In the example above, a \texttt{test} function is
defined in ML, which takes a function \texttt{f} and passes it the
string \texttt{"testing"}. An anonymous JavaScript function is passed
as the \texttt{f} parameter to \texttt{test}.

Note that \texttt{JS} acts both as a language boundary in both types of
embedding and as a value constructor for JavaScript values.

\section{Starting point}

This project will involve material from \emph{Types} (deal with
language boundaries), \emph{Semantics of Programming Languages}
(specify the behavior of the framework), \emph{Compiler Construction}
(analyze the runtime of the JavaScript engine to integrate it) and
\emph{Foundations of Computer Science} (functional programming, ML).

Apart from (re-)familiarizing myself with that material, I will also
study research papers (mainly the ones cited in this proposal).

\section{Resources required}

In this project, I will make use of a JavaScript engine. My initial
intention is to use Google's \emph{V8} engine, but I will leave open
the possibility of using a different engine in case V8 proves to be
more problematic than expected. The implementation will be completed
on my own laptop using an ML-like functional programming language
(\fs).

It is possible that a contracts library will be required in JavaScript. 

\section{Substance and structure of the project}

The goal of this project is to design and implement a framework for
the multilanguage programming paradigm. Work will be done in the
following areas:

\subsection{Type system}
JavaScript is an untyped\footnote{There is
some confusion with the terms \emph{dynamically typed} and
\emph{untyped}. In the academic literature, the term dynamically typed
was introduced much later than untyped to mean the same
concept. Perhaps the best categorization for JavaScript is
\emph{weakly dynamically typed}.}  language, while \fs\ has strong
static typing with type inference.

\subsubsection*{To be done}
\begin{enumerate}
\item Define types for the lump and the natural embedding.
\item Handle types at the boundaries of the programming languages,
making sure the type soundness of \fs\ is preserved (possible use of
\emph{contracts}).
\end{enumerate}

\subsection{Evaluation rules}
Evaluation rules differ in both
languages. For instance, JavaScript allows the evaluation of two empty
lists \cite{ECMA-262}; \fs\ however forbids this operation because it
doesn't type check:
\begin{verbatim}
(JavaScript)
js> [] + []

// (empty string)

--------------------
(F#)
> [] + [];;

  [] + [];;
  -----^^

stdin(1,6): error FS0001: None of the types ''a list, 'a list' support
                          the operator '+'
\end{verbatim}

\subsubsection*{To be done}
\begin{enumerate}

\item Define new rules for the evaluation of programs where language
boundaries exist (e.g., \fs's runtime calls a JavaScript function
with an ML-native value).

\item Define the behavior of the framework if mismatching types are
used across the boundaries.
\end{enumerate}


\subsection{Values}

This is important for the natural embedding (conversion of primitive
datatypes to allow foreign values to have a native type). For instance,
JavaScript treats all numbers as floating point numbers:

\begin{verbatim}
(JavaScript)
js> 1000000000000000000 + 1
1000000000000000000
js> 4611686018427387903 + 1
4611686018427388000
--------------------
(OCaml)
# 1000000000000000000 + 1;;
- : int = 1000000000000000001
# 4611686018427387903 + 1;;
- : int = -4611686018427387904
\end{verbatim}

\subsubsection*{To be done}

\begin{enumerate}
\item Define conversion strategies for values of primitive types.
\item Provide \emph{glue} code to cope with cross-boundary calls.
\end{enumerate}

\subsection{Correctness}
Design automated tests of correctness for the lump and natural
embeddings.

\section{Possible extensions}
\begin{enumerate}

\item Syntax-check JavaScript using \fs\ type providers.
\item Allow passing of native objects between the languages. JavaScript
objects could be represented as records in \fs.
\item Allow passing other native non-primitive values: collections,
exceptions, etc.
\end{enumerate}

% \Needspace{7\baselineskip}
\section{Evaluation strategy}

Quantitative:
\begin{itemize}

\item Compare the performance difference between the system
implementing the lump embedding and the natural embedding.

\item Estimate the relationship between the number of “foreign”
  boundary crossings and the execution time.

\item Compare the performance difference with other systems that allow
  some interoperability between \fs\ and JavaScript.

\end{itemize}

Qualitative:
\begin{itemize}

\item Show the expressiveness of the system.

\item Evaluate of correctness, by executing some tests.

\end{itemize}


\section{Backup strategy}

All source files (code and \LaTeX) are in my local machine in a
\emph{Git} repository, which is hosted on \emph{Bitbucket} and also
replicated to the \emph{Desktop Services} (DS) servers provided by the
Computer Laboratory\footnote{with hostname
\texttt{linux.cl.ds.cam.ac.uk}.}.  The Git repository will be useful
when writing the dissertation as it will be used as a work log.

\section{Success criteria}

\begin{enumerate}

\item The lump embedding implementation should be able to pass values
  from JavaScript to \fs\ and then pass them back.

\item The resulting framework should not take significantly more time
  than executing the respective monolingual runtimes.

\item The natural embedding should be able to pass a function from
JavaScript to \fs\ (and vice versa) and invoke it on the other side of
the boundary. It should also be able to convert primitive datatypes
between the two languages.

\item A convenient syntax for multilanguage programming has been
  designed.

\item Tests of correctness have been passed.

\end{enumerate}

\section{Timetable and milestones}

\subsection*{Michaelmas}
\subsubsection*{Preparation I: 18.10.2012 - 31.10.2012} Install \fs\
on my laptop (using the Mono framework for .NET); install Windows as a
fallback. Revise ML and become familiar with the differences in
\fs. Keep reading research papers and articles about the
subject. Research JavaScript engines and decide which one offers the
best API to access JavaScript values.  \\\textbf{\emph{Milestone:}}
Have a working development environment and a chosen JavaScript engine.

\subsubsection*{Preparation II: 01.10.2012 - 14.11.2012 } Investigate
and test accessing values from the JavaScript engine into \fs. Decide
on a specific syntax for embedding JavaScript inside \fs. If time
allows, start the implementation of the \emph{lump embedding}.
\\\textbf{\emph{Milestone:}} The plan for the implementation is
finished.

\subsubsection*{Implementation I: 15.11.2012 - 28.11.2012} Implement
JavaScript values as \texttt{Lumps} in \fs. Finish the lump embedding
implementation.  \\\textbf{\emph{Milestone:}} Have a working version
of the lump embedding.  Start implementing the \emph{natural
embedding}.

\subsection*{Christmas break}
\subsubsection*{Implementation II: 29.11.2012 - 12.12.2012} Implement
conversion of primitive datatypes, using the JavaScript engine chosen
in Preparation I.  \\\textbf{\emph{Milestone:}} \fs\ can interact with
primitive datatypes from JavaScript and vice versa.

\subsubsection*{Implementation III: 13.12.2012 - 26.12.2012} Implement
wrappers that allow treating JavaScript functions as \fs\ functions.
Start designing correctness tests and begin implementing them.
\\\textbf{\emph{Milestone:}} \fs\ can now call JavaScript functions.

\subsubsection*{Implementation IV: 27.12.2012 - 09.01.2012}
Investigate the use of contracts to implement wrappers that allow
treating \fs\ functions as JavaScript functions.  Test current
implementation with the correctness tests; modify the implementation
until all tests are passed.  \\\textbf{\emph{Milestone:}} JavaScript
can now call \fs\ functions and the correctness tests are passed.

\subsection*{Lent}
\subsubsection*{Extensions: 10.01.2012 - 23.01.2012} Implement some
extensions, depending on the progress of the core. The core must be in
a state in which the implementation section can be written and the
evaluation can be performed. If this is not the case, finalize any
parts of the implementation which proved to be harder than expected.
\\\textbf{\emph{Milestone:}} the core implementation of the project is
finished.

\subsubsection*{Progress report \& write-up I: 24.01.2012 -
06.02.2012} Write the progress report and prepare the progress
presentation slides. Write the introduction, preparation and
implementation sections.  \\\textbf{\emph{Milestone:}} the
dissertation document has been started.

\subsubsection*{Write-up II: 07.02.2012 - 20.02.2012} Finish off the
following sections: preparation and implementation.  Take evaluation
metrics.  \\\textbf{\emph{Milestone:}} preparation and implementation
are finished. Evaluation data is gathered.

\subsubsection*{Write-up III: 21.02.2012 - 06.03.2012} Write the
evaluation and conclusion sections of the dissertation.
\\\textbf{\emph{Milestone:}} a draft of the whole dissertation is now
complete.

\subsubsection*{Write-up IV: 07.03.2012 - 20.03.2012} Make formatting
changes to the document. Send final draft to my supervisor and make
small adjustments if suggested.  \\\textbf{\emph{Milestone:}} the
document's formatting is final.

\subsection*{Easter break}
\subsubsection*{Final editing and submission: 21.03.2012 - 03.04.2012}
Make any last-minute minor changes to the dissertation / code if
suggested by my supervisor or DoS.  \\\textbf{\emph{Milestone:}} have
the dissertation approved, hand it in.

\bibliography{bibliography}

\end{document}
